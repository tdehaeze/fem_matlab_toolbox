#+TITLE: Finite Element Model - Matlab Toolbox
:DRAWER:
#+STARTUP: overview

#+LANGUAGE: en
#+EMAIL: dehaeze.thomas@gmail.com
#+AUTHOR: Dehaeze Thomas

#+HTML_LINK_HOME: ./index.html
#+HTML_LINK_UP: ./index.html

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/readtheorg.css"/>
#+HTML_HEAD: <script src="./js/jquery.min.js"></script>
#+HTML_HEAD: <script src="./js/bootstrap.min.js"></script>
#+HTML_HEAD: <script src="./js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script src="./js/readtheorg.js"></script>

#+PROPERTY: header-args:matlab  :session *MATLAB*
#+PROPERTY: header-args:matlab+ :comments org
#+PROPERTY: header-args:matlab+ :results none
#+PROPERTY: header-args:matlab+ :exports both
#+PROPERTY: header-args:matlab+ :eval no-export
#+PROPERTY: header-args:matlab+ :output-dir figs
#+PROPERTY: header-args:matlab+ :tangle no
#+PROPERTY: header-args:matlab+ :mkdirp yes

#+PROPERTY: header-args:shell  :eval no-export

#+PROPERTY: header-args:latex  :headers '("\\usepackage{tikz}" "\\usepackage{import}" "\\import{$HOME/Cloud/tikz/org/}{config.tex}")
#+PROPERTY: header-args:latex+ :imagemagick t :fit yes
#+PROPERTY: header-args:latex+ :iminoptions -scale 100% -density 150
#+PROPERTY: header-args:latex+ :imoutoptions -quality 100
#+PROPERTY: header-args:latex+ :results raw replace :buffer no
#+PROPERTY: header-args:latex+ :eval no-export
#+PROPERTY: header-args:latex+ :exports results
#+PROPERTY: header-args:latex+ :mkdirp yes
#+PROPERTY: header-args:latex+ :output-dir figs
:END:

* Introduction                                                        :ignore:
This small toolbox provides a set of functions to help using flexible elements on Simscape from a Finite Element Software.

The functions are all described in section [[sec:functions]].

Few examples are provided in the following sections.

* Import Flexible Elements in Simscape using Component Mode Synthesis in Ansys
:PROPERTIES:
:header-args:matlab+: :tangle examples/cant_beam/cant_beam.m
:header-args:matlab+: :comments none :mkdirp yes
:END:

** Introduction                                                      :ignore:
In this section, we wish to model a simple flexible cantilever beam using Simscape.

The cantilever beam is first defined in Ansys.
The reduced Mass and Stiffness matrices are then exported using the Component Mode Synthesis.

The coordinates of interface nodes (nodes where forces can be applied, displacements measured, and connections with other elements) are also exported.

First, these information are imported in Matlab, and then are used in Simscape to model the flexible element.

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./src/');
  addpath('examples/cant_beam/');
#+end_src

** Import Mass Matrix, Stiffness Matrix, and Interface Nodes Coordinates
We first extract the stiffness matrix.
#+begin_src matlab
  K = extractMatrix('cant_beam_K.txt');
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable(K(1:10, 1:10), {}, {}, ' %.1e ');
#+end_src

#+caption: First 10x10 elements of the Stiffness matrix
#+RESULTS:
|  42000.0 |    0.0 |     0.0 |       0.0 |       0.0 |       0.0 | -42000.0 |     0.0 |    0.0 |       0.0 |
|      0.0 |   17.0 |     0.0 |       0.0 |       0.0 |    4200.0 |      0.0 |   -17.0 |    0.0 |       0.0 |
|      0.0 |    0.0 |    17.0 |       0.0 |   -4200.0 |       0.0 |      0.0 |     0.0 |  -17.0 |       0.0 |
|      0.0 |    0.0 |     0.0 |  230000.0 |       0.0 |       0.0 |      0.0 |     0.0 |    0.0 | -230000.0 |
|      0.0 |    0.0 | -4200.0 |       0.0 | 1400000.0 |       0.0 |      0.0 |     0.0 | 4200.0 |       0.0 |
|      0.0 | 4200.0 |     0.0 |       0.0 |       0.0 | 1400000.0 |      0.0 | -4200.0 |    0.0 |       0.0 |
| -42000.0 |    0.0 |     0.0 |       0.0 |       0.0 |       0.0 |  84000.0 |     0.0 |    0.0 |       0.0 |
|      0.0 |  -17.0 |     0.0 |       0.0 |       0.0 |   -4200.0 |      0.0 |    34.0 |    0.0 |       0.0 |
|      0.0 |    0.0 |   -17.0 |       0.0 |    4200.0 |       0.0 |      0.0 |     0.0 |   34.0 |       0.0 |
|      0.0 |    0.0 |     0.0 | -230000.0 |       0.0 |       0.0 |      0.0 |     0.0 |    0.0 |  460000.0 |

#+begin_src matlab
  M = extractMatrix('cant_beam_M.txt');
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable(M(1:10, 1:10), {}, {}, ' %.1e ');
#+end_src

#+caption: First 10x10 elements of the Mass matrix
#+RESULTS:
| 0.00013 |     0.0 |     0.0 |    0.0 |    0.0 |   0.0 | 6.5e-05 |     0.0 |     0.0 |    0.0 |
|     0.0 | 0.00014 |     0.0 |    0.0 |    0.0 |  0.01 |     0.0 |   5e-05 |     0.0 |    0.0 |
|     0.0 |     0.0 | 0.00014 |    0.0 |  -0.01 |   0.0 |     0.0 |     0.0 |   5e-05 |    0.0 |
|     0.0 |     0.0 |     0.0 | 0.0022 |    0.0 |   0.0 |     0.0 |     0.0 |     0.0 | 0.0011 |
|     0.0 |     0.0 |   -0.01 |    0.0 |   0.93 |   0.0 |     0.0 |     0.0 |  -0.006 |    0.0 |
|     0.0 |    0.01 |     0.0 |    0.0 |    0.0 |  0.93 |     0.0 |   0.006 |     0.0 |    0.0 |
| 6.5e-05 |     0.0 |     0.0 |    0.0 |    0.0 |   0.0 | 0.00026 |     0.0 |     0.0 |    0.0 |
|     0.0 |   5e-05 |     0.0 |    0.0 |    0.0 | 0.006 |     0.0 | 0.00029 |     0.0 |    0.0 |
|     0.0 |     0.0 |   5e-05 |    0.0 | -0.006 |   0.0 |     0.0 |     0.0 | 0.00029 |    0.0 |
|     0.0 |     0.0 |     0.0 | 0.0011 |    0.0 |   0.0 |     0.0 |     0.0 |     0.0 | 0.0043 |

Then, we extract the coordinates of the interface nodes.
#+begin_src matlab
  [int_xyz, int_i] = extractNodes('cant_beam.txt');
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no :post addhdr(*this*)
  data2orgtable([int_i, int_xyz], {}, {'Node Number', 'x', 'y', 'z'}, ' %.0f ');
#+end_src

#+caption: Coordinates of the interface nodes
#+RESULTS:
| Node Number |    x | y | z |
|-------------+------+---+---|
|           1 |    0 | 0 | 0 |
|           6 |  500 | 0 | 0 |
|          22 | 1000 | 0 | 0 |

Using =K=, =M= and =int_xyz=, we can use the =Reduced Order Flexible Solid= simscape block.

** Identification of the Dynamics
The flexible element is imported using the =Reduced Order Flexible Solid= simscape block.

The beginning of the cantilever beam is fixed to the World frame, a force actuator is added in the z direction on the middle node, and a z-displacement sensor is added at the end of the beam.

#+begin_src matlab :exports none
  open('cant_beam');
#+end_src

The dynamics is identified from the applied force to the measured displacement (Figure [[fig:cant_beam_frf]]).

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'cant_beam';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/F'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/z'], 1, 'openoutput'); io_i = io_i + 1;

  G = linearize(mdl, io);
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-2, 4, 1000);

  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(G, freqs, 'Hz'))), 'k-');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); xlabel('Frequency [Hz]');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/cant_beam_frf.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:cant_beam_frf
#+caption: Identify transfer function from a vertical force applied at the middle point of the cantilever beam to its vertical displacement
#+RESULTS:
[[file:figs/cant_beam_frf.png]]

* Low Order Dynamical Model from a Finite Element Model
:PROPERTIES:
:header-args:matlab+: :tangle examples/cant_beam/cant_beam.m
:header-args:matlab+: :comments none :mkdirp yes
:END:

** Introduction                                                      :ignore:
Most of the example presented in this section are taken from cite:hatch00_vibrat_matlab_ansys.

The goal is to obtain a low order model from a Finite Element Model.

We suppose here that the eigenvalues and eigenvectors are exported using a Finite Element software.

Once the eigenvalues and eigenvectors are imported, one should choose the inputs and outputs nodes (e.g. where the forces and the displacements are measured) to first reduce the number of eigenvectors.

Damping can then be added to each.

Then, in order to reduce the size of the model, only few modes are included in the model.
The selection of the modes to keep in the model can be based on the "dc gain" or "peak gain" method depending on the damping.

Finally, the full model and reduced models are compared.

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./src/');
  addpath('examples/cant_beam_ansys/');
#+end_src

** Extract Eigenvalues and Eigenvectors
The eigenvalues and eigenvectors are extracted.
#+begin_src matlab
  [xn, f0] = extractEigs('cantbeam30bl.eig', 'dirs', [1 0 0 0 0 0]');

  n_nodes = size(xn, 1);
  n_modes = size(xn, 2);
#+end_src

** Define Physical Inputs and Outputs
First, define the node numbers corresponding to the inputs and outputs
#+begin_src matlab
  i_input = 14; % middle of the beam
  i_output = 29; % end of the beam
#+end_src

** Define Damping
We here use uniform damping.
#+begin_src matlab
  xi = 0.01;
#+end_src

** All Modes Included in the Model
The state space matrices are created by "inspection".
Here, we include all the modes.


System Matrix - A
#+begin_src matlab
  Adiag = zeros(2*n_modes,1);
  Adiag(2:2:end) = -2*xi.*(2*pi*f0);

  Adiagsup = zeros(2*n_modes-1,1);
  Adiagsup(1:2:end) = 1;

  Adiaginf = zeros(2*n_modes-1,1);
  Adiaginf(1:2:end) = -(2*pi*f0).^2;

  A = diag(Adiag) + diag(Adiagsup, 1) + diag(Adiaginf, -1);
#+end_src

System Matrix - B
#+begin_src matlab
  B = zeros(2*n_modes, length(i_input));

  for i = 1:length(i_input)
      % Physical Coordinates
      Fp = zeros(n_nodes, 1);
      Fp(i_input(i)) = 1;

      B(2:2:end, i) = xn'*Fp;
  end
#+end_src

System Matrix - C
#+begin_src matlab
  C = zeros(length(i_output), 2*n_modes);
  C(:, 1:2:end) = xn(i_output, :);
#+end_src

System Matrix - D
#+begin_src matlab
  D = zeros(length(i_output), length(i_input));
#+end_src

State Space Model
#+begin_src matlab
  G_f = ss(A, B, C, D);
#+end_src

** Simple mode truncation
Let see what happens is we simply truncate the number of modes (keeping only the low frequency modes).

The frequency of the modes are shown in Figure [[fig:hatch00_cant_beam_modes_freq]].

The DC gain of each mode is shown in Figure [[fig:hatch00_cant_beam_unsorted_dc_gains]].

#+begin_src matlab :exports none
  figure;
  plot(1:n_modes, f0, 'ko-');
  xlabel('Mode Number'); ylabel('Frequency [Hz]');
  set(gca, 'XScale', 'lin'); set(gca, 'YScale', 'log');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/hatch00_cant_beam_modes_freq.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:hatch00_cant_beam_modes_freq
#+caption: Frequency of the modes
#+RESULTS:
[[file:figs/hatch00_cant_beam_modes_freq.png]]

#+begin_src matlab :exports none
  dc_gain = abs(xn(i_input, :).*xn(i_output, :))./(2*pi*f0).^2;

  figure;
  plot(1:n_modes, dc_gain, 'ko-');
  xlabel('Sorted Modes'); ylabel('DC Values');
  set(gca, 'XScale', 'lin'); set(gca, 'YScale', 'log');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/hatch00_cant_beam_unsorted_dc_gains.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:hatch00_cant_beam_unsorted_dc_gains
#+caption: Unsorted DC Gains
#+RESULTS:
[[file:figs/hatch00_cant_beam_unsorted_dc_gains.png]]

Let's keep only the first 10 modes.
#+begin_src matlab
  m_max = 10;
  xn_t = xn(:, 1:m_max);
  f0_t = f0(1:m_max);
#+end_src

#+begin_src matlab :exports none
  Adiag = zeros(2*m_max,1);
  Adiag(2:2:end) = -2*xi.*(2*pi*f0_t);

  Adiagsup = zeros(2*m_max-1,1);
  Adiagsup(1:2:end) = 1;

  Adiaginf = zeros(2*m_max-1,1);
  Adiaginf(1:2:end) = -(2*pi*f0_t).^2;

  A = diag(Adiag) + diag(Adiagsup, 1) + diag(Adiaginf, -1);
#+end_src

#+begin_src matlab :exports none
  B = zeros(2*m_max, length(i_input));

  for i = 1:length(i_input)
      % Physical Coordinates
      Fp = zeros(n_nodes, 1);
      Fp(i_input(i)) = 1;

      B(2:2:end, i) = xn_t'*Fp;
  end
#+end_src

#+begin_src matlab :exports none
  C = zeros(length(i_output), 2*m_max);
  C(:, 1:2:end) = xn_t(i_output, :);
#+end_src

#+begin_src matlab :exports none
  D = zeros(length(i_output), length(i_input));
#+end_src

And create the state space model with the kept modes:
#+begin_src matlab :exports none
  G_t = ss(A, B, C, D);
#+end_src

** Modes sorted by their DC gain
Let's sort the modes by their DC gains and plot their sorted DC gains (Figure [[fig:hatch00_cant_beam_sorted_dc_gains]]).

#+begin_src matlab
  dc_gain = abs(xn(i_input, :).*xn(i_output, :))./(2*pi*f0).^2;

  [dc_gain_sort, index_sort] = sort(dc_gain, 'descend');
#+end_src

#+begin_src matlab :exports none
  figure;
  plot(1:n_modes, dc_gain_sort, 'ko-');
  xlabel('Sorted Modes'); ylabel('DC Values');
  set(gca, 'XScale', 'lin'); set(gca, 'YScale', 'log');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/hatch00_cant_beam_sorted_dc_gains.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:hatch00_cant_beam_sorted_dc_gains
#+caption: Sorted DC Gains
#+RESULTS:
[[file:figs/hatch00_cant_beam_sorted_dc_gains.png]]

Let's keep only the first 10 *sorted* modes.
#+begin_src matlab
  m_max = 10;

  xn_s = xn(:, index_sort(1:m_max));
  f0_s = f0(index_sort(1:m_max));
#+end_src

#+begin_src matlab :exports none
  Adiag = zeros(2*m_max,1);
  Adiag(2:2:end) = -2*xi.*(2*pi*f0_s);

  Adiagsup = zeros(2*m_max-1,1);
  Adiagsup(1:2:end) = 1;

  Adiaginf = zeros(2*m_max-1,1);
  Adiaginf(1:2:end) = -(2*pi*f0_s).^2;

  A = diag(Adiag) + diag(Adiagsup, 1) + diag(Adiaginf, -1);
#+end_src

#+begin_src matlab :exports none
  B = zeros(2*m_max, length(i_input));

  for i = 1:length(i_input)
      % Physical Coordinates
      Fp = zeros(n_nodes, 1);
      Fp(i_input(i)) = 1;

      B(2:2:end, i) = xn_s'*Fp;
  end
#+end_src

#+begin_src matlab :exports none
  C = zeros(length(i_output), 2*m_max);
  C(:, 1:2:end) = xn_s(i_output, :);
#+end_src

#+begin_src matlab :exports none
  D = zeros(length(i_output), length(i_input));
#+end_src

And create the state space model with the kept modes:
#+begin_src matlab
  G_s = ss(A, B, C, D);
#+end_src

** Comparison
The following models are compared on Figure [[fig:cant_beam_comp_reduc_techniques]]:
- full model containing all the modes
- the truncated model containing only the low frequency modes
- the model where modes are sorted based on DC gain before selection

One can see that with the same number of modes, the sorted model gives much better results than the truncated one.

#+begin_src matlab :exports none
  freqs = logspace(0, 5, 1000);

  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(G_f, freqs, 'Hz'))), 'DisplayName', 'Full');
  plot(freqs, abs(squeeze(freqresp(G_t, freqs, 'Hz'))), 'DisplayName', 'Trun');
  plot(freqs, abs(squeeze(freqresp(G_s, freqs, 'Hz'))), 'DisplayName', 'Sort');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); xlabel('Frequency [Hz]');
  legend();
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/cant_beam_comp_reduc_techniques.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:cant_beam_comp_reduc_techniques
#+caption: Comparison of the reduction techniques
#+RESULTS:
[[file:figs/cant_beam_comp_reduc_techniques.png]]

** Effect of the Individual Modes
To see why it is better to sort the modes prior mode reduction, we can look at the contribution of the individual modes as shown in Figure [[fig:cant_beam_individial_modes]].

One can see that some modes have no effect on the dynamics for the selected inputs and outputs.

#+begin_src matlab
  freqs = logspace(0, 4, 1000);

  figure;
  hold on;
  for mode_i = 1:10
      A = zeros(2);
      A(2,2) = -2*xi.*(2*pi*f0(mode_i));
      A(1,2) = 1;
      A(2,1) = -(2*pi*f0(mode_i)).^2;

      B = [0; xn(i_input, mode_i)'];

      C = [xn(i_output, mode_i), 0];

      D = zeros(length(i_output), length(i_input));

      plot(freqs, abs(squeeze(freqresp(ss(A,B,C,D), freqs, 'Hz'))), ...
           'DisplayName', sprintf('Mode %i', mode_i));
  end
  plot(freqs, abs(squeeze(freqresp(G_f, freqs, 'Hz'))), 'k--', ...
       'DisplayName', 'Full');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); xlabel('Frequency [Hz]');
  ylim([1e-9, 1e2]);
  legend('location', 'southwest');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/cant_beam_individial_modes.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:cant_beam_individial_modes
#+caption: Contribution of the individual modes on the dynamics
#+RESULTS:
[[file:figs/cant_beam_individial_modes.png]]

** Non-Uniform Damping
*** Definition of the Damping
Let's say we want to use Rayleigh damping:
\begin{equation}
  \xi_i = \frac{a + b \omega_i^2}{\omega_i}
\end{equation}

We define the parameters on Matlab:
#+begin_src matlab
  a = 1e-2;
  b = 1e-6;
  xi = (a + b * (2*pi*f0).^2)./(2*pi*f0);
#+end_src

*** State Space Model
And we can create the state space model.

System Matrix - A
#+begin_src matlab
  Adiag = zeros(2*n_modes,1);
  Adiag(2:2:end) = -2*xi.*(2*pi*f0);

  Adiagsup = zeros(2*n_modes-1,1);
  Adiagsup(1:2:end) = 1;

  Adiaginf = zeros(2*n_modes-1,1);
  Adiaginf(1:2:end) = -(2*pi*f0).^2;

  A = diag(Adiag) + diag(Adiagsup, 1) + diag(Adiaginf, -1);
#+end_src

System Matrix - B
#+begin_src matlab
  B = zeros(2*n_modes, length(i_input));

  for i = 1:length(i_input)
      % Physical Coordinates
      Fp = zeros(n_nodes, 1);
      Fp(i_input(i)) = 1;

      B(2:2:end, i) = xn'*Fp;
  end
#+end_src

System Matrix - C
#+begin_src matlab
  C = zeros(length(i_output), 2*n_modes);
  C(:, 1:2:end) = xn(i_output, :);
#+end_src

System Matrix - D
#+begin_src matlab
  D = zeros(length(i_output), length(i_input));
#+end_src

State Space Model
#+begin_src matlab
  G_d = ss(A, B, C, D);
#+end_src

*** Obtained Dynamics

And we compare the obtained dynamics when using Uniform Damping (Figure [[fig:cant_beam_comp_unif_non_unif_damp]]).

#+begin_src matlab :exports none
  freqs = logspace(0, 5, 1000);

  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(G_f, freqs, 'Hz'))), 'DisplayName', 'Uniform Damping');
  plot(freqs, abs(squeeze(freqresp(G_d, freqs, 'Hz'))), 'DisplayName', 'Non-Uniform Damping');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); xlabel('Frequency [Hz]');
  legend();
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/cant_beam_comp_unif_non_unif_damp.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:cant_beam_comp_unif_non_unif_damp
#+caption: Comparison of the obtained dynamics with uniform damping and non-uniform damping
#+RESULTS:
[[file:figs/cant_beam_comp_unif_non_unif_damp.png]]

*** Sort Modes based on their peak gain
The modes are sorted by their peak gain.
The obtained sorted peak gains for each mode are shown in figure [[fig:cant_beam_peak_gains_sorted]].

#+begin_src matlab
  dc_gain = abs(xn(i_input, :).*xn(i_output, :))./(2*pi*f0).^2;
  peak_gain = dc_gain./xi;

  [peak_gain_sort, index_sort] = sort(peak_gain, 'descend');
#+end_src

#+begin_src matlab :exports none
  figure;
  plot(1:n_modes, peak_gain_sort, 'ko-');
  xlabel('Sorted Modes'); ylabel('Peak Values');
  set(gca, 'XScale', 'lin'); set(gca, 'YScale', 'log');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/cant_beam_peak_gains_sorted.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:cant_beam_peak_gains_sorted
#+caption: Sorted Peak Gains
#+RESULTS:
[[file:figs/cant_beam_peak_gains_sorted.png]]

*** Model Reduction
Let's keep only the first 10 *sorted* modes.

#+begin_src matlab
  m_max = 10;

  xn_s = xn(:, index_sort(1:m_max));
  f0_s = f0(index_sort(1:m_max));
  xi_s = xi(index_sort(1:m_max));
#+end_src

And we create the state space matrices.

#+begin_src matlab
  Adiag = zeros(2*m_max,1);
  Adiag(2:2:end) = -2*xi_s.*(2*pi*f0_s);

  Adiagsup = zeros(2*m_max-1,1);
  Adiagsup(1:2:end) = 1;

  Adiaginf = zeros(2*m_max-1,1);
  Adiaginf(1:2:end) = -(2*pi*f0_s).^2;

  A = diag(Adiag) + diag(Adiagsup, 1) + diag(Adiaginf, -1);
#+end_src

#+begin_src matlab
  B = zeros(2*m_max, length(i_input));

  for i = 1:length(i_input)
      % Physical Coordinates
      Fp = zeros(n_nodes, 1);
      Fp(i_input(i)) = 1;

      B(2:2:end, i) = xn_s'*Fp;
  end
#+end_src

#+begin_src matlab
  C = zeros(length(i_output), 2*m_max);
  C(:, 1:2:end) = xn_s(i_output, :);
#+end_src

#+begin_src matlab
  D = zeros(length(i_output), length(i_input));
#+end_src

And finally the reduced State Space Model is created and compared with the full model in Figure [[fig:cant_beam_non_uniform_damp_reduced_dynamics]].
#+begin_src matlab
  G_p = ss(A, B, C, D);
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(0, 5, 1000);

  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(G_f, freqs, 'Hz'))), 'DisplayName', 'Uniform Damping');
  plot(freqs, abs(squeeze(freqresp(G_d, freqs, 'Hz'))), 'DisplayName', 'Non-Uniform Damping');
  plot(freqs, abs(squeeze(freqresp(G_p, freqs, 'Hz'))), 'DisplayName', 'Peak sort');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); xlabel('Frequency [Hz]');
  legend();
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/cant_beam_non_uniform_damp_reduced_dynamics.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:cant_beam_non_uniform_damp_reduced_dynamics
#+caption: Comparison of the full and reduced model for the non-uniform damping case
#+RESULTS:
[[file:figs/cant_beam_non_uniform_damp_reduced_dynamics.png]]


** MIMO System
*** Introduction                                                    :ignore:
When using multiple inputs and multiple outputs, one cannot simply choose the modes to keep based on their gains because this gain depends on the inputs and outputs chosen.

In such case, *balancing reduction* should be used.

*** Inputs and Outputs
Let's choose two inputs and two outputs.
#+begin_src matlab
  i_input = [14, 31];
  i_output = [14, 31];
#+end_src

*** Full Model
The state space matrices are created by inspection.

#+begin_src matlab
  Adiag = zeros(2*n_modes,1);
  Adiag(2:2:end) = -2*xi.*(2*pi*f0);

  Adiagsup = zeros(2*n_modes-1,1);
  Adiagsup(1:2:end) = 1;

  Adiaginf = zeros(2*n_modes-1,1);
  Adiaginf(1:2:end) = -(2*pi*f0).^2;

  A = diag(Adiag) + diag(Adiagsup, 1) + diag(Adiaginf, -1);
#+end_src

#+begin_src matlab
  B = zeros(2*n_modes, length(i_input));

  for i = 1:length(i_input)
      % Physical Coordinates
      Fp = zeros(n_nodes, 1);
      Fp(i_input(i)) = 1;

      B(2:2:end, i) = xn'*Fp;
  end
#+end_src

#+begin_src matlab
  C = zeros(length(i_output), 2*n_modes);
  C(:, 1:2:end) = xn(i_output, :);
#+end_src

#+begin_src matlab
  D = zeros(length(i_output), length(i_input));
#+end_src

And the State Space Model is created.
#+begin_src matlab
  G_m = ss(A, B, C, D);
#+end_src

*** Balancing Reduction
First, we have to make sure that the rigid body mode is not included in the system (here it is not).

Then, we compute the *controllability and observability gramians*.
#+begin_src matlab
  wc = gram(G_m, 'c');
  wo = gram(G_m, 'o');
#+end_src

And we plot the diagonal terms of the controllability and observability gramians (Figure [[fig:cant_beam_gramians]]).
The states representing the position and velocity are separated.

#+begin_src matlab :exports none
  figure;

  subplot(1,2,1);
  title('Observability Gramians')
  hold on;
  plot(1:2:size(A,1), diag(wo(1:2:end, 1:2:end)), 'x', ...
       'DisplayName', 'pos');
  plot(2:2:size(A,1), diag(wo(2:2:end, 2:2:end)), 'o', ...
       'DisplayName', 'vel');
  hold off;
  set(gca, 'XScale', 'lin'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); xlabel('States');
  legend();

  subplot(1,2,2);
  title('Controllability Gramians')
  hold on;
  plot(1:2:size(A,1), diag(wc(1:2:end, 1:2:end)), 'x', ...
       'DisplayName', 'pos');
  plot(2:2:size(A,1), diag(wc(2:2:end, 2:2:end)), 'o', ...
       'DisplayName', 'vel');
  hold off;
  set(gca, 'XScale', 'lin'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); xlabel('States');
  legend();
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/cant_beam_gramians.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:cant_beam_gramians
#+caption: Diagonal values of the Observability and Controllability Gramians
#+RESULTS:
[[file:figs/cant_beam_gramians.png]]

We use =balreal= to rank oscillatory states.
#+begin_quote
    [SYSB,G] = BALREAL(SYS) computes a balanced state-space realization for
    the stable portion of the linear system SYS. For stable systems, SYSB
    is an equivalent realization for which the controllability and
    observability Gramians are equal and diagonal, their diagonal entries
    forming the vector G of Hankel singular values. Small entries in G
    indicate states that can be removed to simplify the model (use MODRED
    to reduce the model order).
#+end_quote

#+begin_src matlab
  [G_b, G, T, Ti] = balreal(G_m);
#+end_src

The diagonal values of the two gramians are shown in Figure [[fig:cant_beam_gramian_balanced]].

#+begin_src matlab :exports none
  figure;
  hold on;
  plot(G, 'k.-');
  hold off;
  set(gca, 'XScale', 'lin'); set(gca, 'YScale', 'log');
  ylabel('Diagonal of balanced gramian'); xlabel('State Number');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/cant_beam_gramian_balanced.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:cant_beam_gramian_balanced
#+caption: Sorted values of the Gramian of the balanced realization
#+RESULTS:
[[file:figs/cant_beam_gramian_balanced.png]]

Now we can choose the number of states to keep.
#+begin_src matlab
  n_states_b = 10;
#+end_src

We now use =modred= to define reduced order oscillatory system using =mathdc= or =truncate= option.
#+begin_quote
 MODRED  Model simplification by state elimination.

    RSYS = MODRED(SYS,ELIM) simplifies the state-space model SYS by
    discarding the states specified in the vector ELIM. The full state
    vector X is partitioned as X = [X1;X2] where Xr=X1 is the reduced
    state vector and X2 is discarded.
#+end_quote

#+begin_src matlab
  G_br = modred(G_b, n_states_b+1:size(A,1), 'truncate');
#+end_src

If needed, the rigid body mode should be added to the reduced system.

And other option is to specify the minimum value of the gramians diagonal elements for the modes to keep.
#+begin_src matlab :eval no
  G_min = 1e-4;
  G_br = modred(G_b, G<G_min, 'truncate');
#+end_src

The obtained reduced dynamics is shown in Figure [[fig:cant_beam_mimo_reduction]].

#+begin_src matlab :exports none
  freqs = logspace(0, 4, 1000);

  figure;

  ax1 = subplot(2, 2, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G_br(1, 1), freqs, 'Hz'))));
  plot(freqs, abs(squeeze(freqresp(G_m( 1, 1), freqs, 'Hz'))));
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('$\left|Z_1/F_1\right|$');

  ax2 = subplot(2, 2, 2);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G_br(1, 2), freqs, 'Hz'))));
  plot(freqs, abs(squeeze(freqresp(G_m( 1, 2), freqs, 'Hz'))));
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('$\left|Z_1/F_2\right|$');

  ax3 = subplot(2, 2, 3);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G_br(2, 1), freqs, 'Hz'))));
  plot(freqs, abs(squeeze(freqresp(G_m( 2, 1), freqs, 'Hz'))));
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('$\left|Z_2/F_1\right|$');

  ax4 = subplot(2, 2, 4);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G_br(2, 2), freqs, 'Hz'))), 'DisplayName', 'Balanced Red.');
  plot(freqs, abs(squeeze(freqresp(G_m( 2, 2), freqs, 'Hz'))), 'DisplayName', 'Full');
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('$\left|Z_2/F_2\right|$');
  legend('location', 'northeast');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/cant_beam_mimo_reduction.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:cant_beam_mimo_reduction
#+caption: Balanced reduction on the MIMO system
#+RESULTS:
[[file:figs/cant_beam_mimo_reduction.png]]

* Piezoelectric Stack
:PROPERTIES:
:header-args:matlab+: :tangle examples/piezo_stack/piezo_stack.m
:header-args:matlab+: :comments none :mkdirp yes
:END:
** Matlab Init                                             :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./src/');
  addpath('examples/piezo_stack/');
#+end_src

** Import Mass Matrix, Stiffness Matrix, and Interface Nodes Coordinates
We first extract the stiffness and mass matrices.
#+begin_src matlab
  K = extractMatrix('piezo_stack_K.txt');
  M = extractMatrix('piezo_stack_M.txt');
#+end_src

Then, we extract the coordinates of the interface nodes.
#+begin_src matlab
  [int_xyz, int_i, n_xyz, n_i, nodes] = extractNodes('piezo_stack.txt');
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable([length(n_i); length(int_i); size(M,1) - 6*length(int_i); size(M,1)], {'Total number of Nodes', 'Number of interface Nodes', 'Number of Modes', 'Size of M and K matrices'}, {}, ' %.0f ');
#+end_src

#+RESULTS:
| Total number of Nodes     | 1404 |
| Number of interface Nodes |    3 |
| Number of Modes           |  186 |
| Size of M and K matrices  |  204 |

#+begin_src matlab :exports results :results value table replace :tangle no :post addhdr(*this*)
  data2orgtable([int_i, int_xyz], {}, {'Node Number', 'x [m]', 'y [m]', 'z [m]'}, ' %f ');
#+end_src

#+caption: Coordinates of the interface nodes
#+RESULTS:
| Node Number | x [m] | y [m] | z [m] |
|-------------+-------+-------+-------|
|      1402.0 |   0.0 |   0.0 |   0.0 |
|      1403.0 | 0.035 |   0.0 |   0.0 |
|      1404.0 |  0.07 |   0.0 |   0.0 |

#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable(K(1:10, 1:10), {}, {}, ' %.1g ');
#+end_src

#+caption: First 10x10 elements of the Stiffness matrix
#+RESULTS:
|  200000000.0 |           0 |           0 |       0 |         0 |         0 | -200000000.0 |           0 |           0 |       0 |
|            0 |  10000000.0 |           0 |       0 |         0 |  200000.0 |            0 | -10000000.0 |           0 |       0 |
|            0 |           0 |  10000000.0 |   8e-06 | -200000.0 |         0 |            0 |           0 | -10000000.0 |   4e-06 |
|            0 |           0 |       8e-06 |  1000.0 |    -4e-08 |         0 |            0 |           0 |       4e-06 | -1000.0 |
|            0 |           0 |   -200000.0 |  -4e-08 |    6000.0 |         0 |            0 |           0 |    200000.0 |  -3e-08 |
|            0 |    200000.0 |           0 |       0 |         0 |    6000.0 |            0 |   -200000.0 |           0 |       0 |
| -200000000.0 |           0 |           0 |       0 |         0 |         0 |  400000000.0 |           0 |           0 |       0 |
|            0 | -10000000.0 |           0 |       0 |         0 | -200000.0 |            0 |  30000000.0 |           0 |       0 |
|            0 |           0 | -10000000.0 |   4e-06 |  200000.0 |         0 |            0 |           0 |  30000000.0 |   2e-05 |
|            0 |           0 |       4e-06 | -1000.0 |    -3e-08 |         0 |            0 |           0 |       2e-05 |  2000.0 |


#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable(M(1:10, 1:10), {}, {}, ' %.1g ');
#+end_src

#+caption: First 10x10 elements of the Mass matrix
#+RESULTS:
| 0.009 |     0 |      0 |      0 |      0 |     0 | 0.005 |     0 |      0 |      0 |
|     0 |  0.01 |      0 |      0 |      0 | 5e-05 |     0 | 0.004 |      0 |      0 |
|     0 |     0 |   0.01 | -6e-16 | -5e-05 |     0 |     0 |     0 |  0.004 | -5e-16 |
|     0 |     0 | -6e-16 |  2e-07 |  4e-18 |     0 |     0 |     0 | -5e-16 |  8e-08 |
|     0 |     0 | -5e-05 |  4e-18 |  3e-07 |     0 |     0 |     0 | -3e-05 |  4e-18 |
|     0 | 5e-05 |      0 |      0 |      0 | 3e-07 |     0 | 3e-05 |      0 |      0 |
| 0.005 |     0 |      0 |      0 |      0 |     0 |  0.02 |     0 |      0 |      0 |
|     0 | 0.004 |      0 |      0 |      0 | 3e-05 |     0 |  0.02 |      0 |      0 |
|     0 |     0 |  0.004 | -5e-16 | -3e-05 |     0 |     0 |     0 |   0.02 | -1e-15 |
|     0 |     0 | -5e-16 |  8e-08 |  4e-18 |     0 |     0 |     0 | -1e-15 |  3e-07 |

Using =K=, =M= and =int_xyz=, we can use the =Reduced Order Flexible Solid= simscape block.

** Identification of the Dynamics
The flexible element is imported using the =Reduced Order Flexible Solid= simscape block.

To model the actuator, an =Internal Force= block is added between the first and second nodes.
To model the sensors, a =Relative Motion Sensor= block is added between the second and the third nodes.

Two masses are fixed at the ends of the piezo-electric stack actuator.

#+begin_src matlab :exports none
  open('piezo_stack');
#+end_src

We first set the mass to be zero.
#+begin_src matlab
  m = 0;
#+end_src

The dynamics is identified from the applied force to the measured relative displacement.

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'piezo_stack';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/F'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/x'], 1, 'openoutput'); io_i = io_i + 1;

  G = linearize(mdl, io);
#+end_src

Then, we add 1Kg of mass:
#+begin_src matlab
  m = 1;
#+end_src

And the dynamics is identified.

The two identified dynamics are compared in Figure [[fig:piezo_stack_frf]].

#+begin_src matlab :exports none
  %% Name of the Simulink File
  mdl = 'piezo_stack';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/F'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/x'], 1, 'openoutput'); io_i = io_i + 1;

  Gm = linearize(mdl, io);
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(2, 6, 1000);

  figure;

  ax1 = subplot(2,1,1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G, freqs, 'Hz'))), 'k-');
  plot(freqs, abs(squeeze(freqresp(Gm, freqs, 'Hz'))), 'k--');
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); set(gca, 'XTickLabel',[]);
  hold off;

  ax2 = subplot(2,1,2);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(G, freqs, 'Hz'))), 'k-');
  plot(freqs, 180/pi*angle(squeeze(freqresp(Gm, freqs, 'Hz'))), 'k--');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  yticks(-180:90:180);
  ylim([-180 180]);
  xlabel('Frequency [Hz]'); ylabel('Phase [deg]');
  hold off;
  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/piezo_stack_frf.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:piezo_stack_frf
#+caption: Identify transfer function from a vertical force applied at the middle point of the cantilever beam to its vertical displacement
#+RESULTS:
[[file:figs/piezo_stack_frf.png]]

* Piezoelectric Stack with Sensor at the end
:PROPERTIES:
:header-args:matlab+: :tangle examples/piezo_stack_sensor/piezo_stack_sensor.m
:header-args:matlab+: :comments none :mkdirp yes
:END:
** Matlab Init                                             :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./src/');
  addpath('examples/piezo_stack_sensor/');
#+end_src

** Import Mass Matrix, Stiffness Matrix, and Interface Nodes Coordinates
We first extract the stiffness and mass matrices.
#+begin_src matlab
  K = extractMatrix('piezo_stack_sensor_K.txt');
  M = extractMatrix('piezo_stack_sensor_M.txt');
#+end_src

Then, we extract the coordinates of the interface nodes.
#+begin_src matlab
  [int_xyz, int_i, n_xyz, n_i, nodes] = extractNodes('piezo_stack_sensor.txt');
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable([length(n_i); length(int_i); size(M,1) - 6*length(int_i); size(M,1)], {'Total number of Nodes', 'Number of interface Nodes', 'Number of Modes', 'Size of M and K matrices'}, {}, ' %.0f ');
#+end_src

#+RESULTS:
| Total number of Nodes     | 1401 |
| Number of interface Nodes |    3 |
| Number of Modes           |   30 |
| Size of M and K matrices  |   48 |

#+begin_src matlab :exports results :results value table replace :tangle no :post addhdr(*this*)
  data2orgtable([int_i, int_xyz], {}, {'Node Number', 'x [m]', 'y [m]', 'z [m]'}, ' %f ');
#+end_src

#+caption: Coordinates of the interface nodes
#+RESULTS:
| Node Number | x [m] | y [m] | z [m] |
|-------------+-------+-------+-------|
|         1.0 |   0.0 |   0.0 |   0.0 |
|         2.0 |  0.06 |   0.0 |   0.0 |
|         3.0 |  0.07 |   0.0 |   0.0 |

#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable(K(1:10, 1:10), {}, {}, ' %.1e ');
#+end_src

#+caption: First 10x10 elements of the Stiffness matrix
#+RESULTS:
|  110000000.0 |        0.0 |        0.0 |      0.0 |      0.0 |      0.0 | -110000000.0 |         0.0 |         0.0 |      0.0 |
|          0.0 |  2600000.0 |        0.0 |  1.3e-08 |      0.0 |  82000.0 |          0.0 |  -2600000.0 |         0.0 |      0.0 |
|          0.0 |        0.0 |  2600000.0 |  1.5e-05 | -82000.0 |      0.0 |          0.0 |         0.0 |  -2600000.0 |  6.5e-06 |
|          0.0 |    1.3e-08 |    1.5e-05 |    610.0 | -1.3e-07 |  6.3e-13 |          0.0 |     7.8e-13 |     6.5e-06 |   -610.0 |
|          0.0 |        0.0 |   -82000.0 | -1.3e-07 |   3500.0 |      0.0 |          0.0 |         0.0 |     82000.0 | -9.2e-08 |
|          0.0 |    82000.0 |        0.0 |  6.3e-13 |      0.0 |   3500.0 |          0.0 |    -82000.0 |         0.0 |      0.0 |
| -110000000.0 |        0.0 |        0.0 |      0.0 |      0.0 |      0.0 | 1100000000.0 |         0.0 |         0.0 |      0.0 |
|          0.0 | -2600000.0 |        0.0 |  7.8e-13 |      0.0 | -82000.0 |          0.0 | 280000000.0 |         0.0 |      0.0 |
|          0.0 |        0.0 | -2600000.0 |  6.5e-06 |  82000.0 |      0.0 |          0.0 |         0.0 | 280000000.0 |  1.7e-05 |
|          0.0 |        0.0 |    6.5e-06 |   -610.0 | -9.2e-08 |      0.0 |          0.0 |         0.0 |     1.7e-05 |   6100.0 |

#+begin_src matlab :exports results :results value table replace :tangle no
  data2orgtable(M(1:10, 1:10), {}, {}, ' %.1e ');
#+end_src

#+caption: First 10x10 elements of the Mass matrix
#+RESULTS:
|  0.016 |      0.0 |      0.0 |      0.0 |      0.0 |      0.0 | 0.0082 |      0.0 |      0.0 |      0.0 |
|    0.0 |    0.018 |      0.0 | -5.3e-21 |      0.0 |  0.00016 |    0.0 |   0.0064 |      0.0 |      0.0 |
|    0.0 |      0.0 |    0.018 | -5.9e-15 | -0.00016 |      0.0 |    0.0 |      0.0 |   0.0064 | -5.2e-15 |
|    0.0 | -5.3e-21 | -5.9e-15 |  2.7e-07 |  7.7e-17 | -4.7e-23 |    0.0 | -1.9e-21 | -5.2e-15 |  1.4e-07 |
|    0.0 |      0.0 | -0.00016 |  7.7e-17 |  1.9e-06 |      0.0 |    0.0 |      0.0 | -9.8e-05 |  7.2e-17 |
|    0.0 |  0.00016 |      0.0 | -4.7e-23 |      0.0 |  1.9e-06 |    0.0 |  9.8e-05 |      0.0 |      0.0 |
| 0.0082 |      0.0 |      0.0 |      0.0 |      0.0 |      0.0 |  0.018 |      0.0 |      0.0 |      0.0 |
|    0.0 |   0.0064 |      0.0 | -1.9e-21 |      0.0 |  9.8e-05 |    0.0 |     0.02 |      0.0 |      0.0 |
|    0.0 |      0.0 |   0.0064 | -5.2e-15 | -9.8e-05 |      0.0 |    0.0 |      0.0 |     0.02 | -5.9e-15 |
|    0.0 |      0.0 | -5.2e-15 |  1.4e-07 |  7.2e-17 |      0.0 |    0.0 |      0.0 | -5.9e-15 |    3e-07 |

Using =K=, =M= and =int_xyz=, we can use the =Reduced Order Flexible Solid= simscape block.

** Identification of the Dynamics
The flexible element is imported using the =Reduced Order Flexible Solid= simscape block.

To model the actuator, an =Internal Force= block is added between the first and second nodes.
To model the sensors, a =Relative Motion Sensor= block is added between the second and the third nodes.

Two masses are fixed at the ends of the piezo-electric stack actuator.

#+begin_src matlab :exports none
  open('piezo_stack_sensor');
#+end_src

We first set the mass to be zero.
#+begin_src matlab
  m = 0;
#+end_src

The dynamics is identified from the applied force to the measured relative displacement.

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'piezo_stack_sensor';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/F'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/x'], 1, 'openoutput'); io_i = io_i + 1;

  G = linearize(mdl, io);
#+end_src

Then, we add 1Kg of mass:
#+begin_src matlab
  m = 1;
#+end_src

And the dynamics is identified.
#+begin_src matlab :exports none
  %% Name of the Simulink File
  mdl = 'piezo_stack_sensor';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/F'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/x'], 1, 'openoutput'); io_i = io_i + 1;

  Gm = linearize(mdl, io);
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(2, 6, 1000);

  figure;

  ax1 = subplot(2,1,1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G, freqs, 'Hz'))), 'k-');
  plot(freqs, abs(squeeze(freqresp(Gm, freqs, 'Hz'))), 'k--');
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Amplitude'); set(gca, 'XTickLabel',[]);
  hold off;

  ax2 = subplot(2,1,2);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(G, freqs, 'Hz'))), 'k-');
  plot(freqs, 180/pi*angle(squeeze(freqresp(Gm, freqs, 'Hz'))), 'k--');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  yticks(-180:90:180);
  ylim([-180 180]);
  xlabel('Frequency [Hz]'); ylabel('Phase [deg]');
  hold off;
  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
  exportFig('figs/piezo_stack_sensor_frf.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:piezo_stack_sensor_frf
#+caption: Identify transfer function from a vertical force applied at the middle point of the cantilever beam to its vertical displacement
#+RESULTS:
[[file:figs/piezo_stack_sensor_frf.png]]

* Functions
<<sec:functions>>
:PROPERTIES:
:header-args:matlab+: :comments none :mkdirp yes :eval no
:END:

** =extractMatrix=: Extract Mass/Stiffness matrices
:PROPERTIES:
:header-args:matlab+: :tangle src/extractMatrix.m
:header-args:matlab+: :comments none :mkdirp yes :eval no
:END:
<<sec:extractMatrix>>

This Matlab function is accessible [[file:src/extractMatrix.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  function [M] = extractMatrix(filename)
  % extractMatrix -
  %
  % Syntax: [M] = extractMatrix(filename)
  %
  % Inputs:
  %    - filename - relative or absolute path of the file that contains the Matrix
  %
  % Outputs:
  %    - M - Matrix that is contained in the file
#+end_src

*** Optional Parameters
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
      filename
  end
#+end_src


*** Read the file
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  str = fileread(filename);
#+end_src

*** Extract the Matrix
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  str = regexprep(str,'\s+','');

  parts = regexp(str, '\[(?<row>\d+),(?<col>\d+)\]:(?<val>[^\[]+)', 'names');
#+end_src

Get the number of column and rows
#+begin_src matlab
  row = cellfun(@str2double, {parts.row}, 'UniformOutput', true);

  col = cellfun(@str2double, {parts.col}, 'UniformOutput', true);
#+end_src

Get the values of the matrix
#+begin_src matlab
  val = cellfun(@str2double, {parts.val}, 'UniformOutput', true);
#+end_src

Get the size of the matrix
#+begin_src matlab
  sz = [max(row), max(col)];
#+end_src

Create the Matrix with the correct size
#+begin_src matlab
  M = zeros(sz);
#+end_src

Get matrix position corresponding to the values.
#+begin_src matlab
  ix = sub2ind(sz, row, col);
#+end_src

Finally, data are assigned.
#+begin_src matlab
  M(ix)= val;
#+end_src

** =extractNodes=: Extract Nodes positions and Interfaces DoFs
:PROPERTIES:
:header-args:matlab+: :tangle src/extractNodes.m
:header-args:matlab+: :comments none :mkdirp yes :eval no
:END:
<<sec:extractNodes>>

This Matlab function is accessible [[file:src/extractNodes.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  function [int_xyz, int_i, n_xyz, n_i, nodes] = extractNodes(filename)
  % extractNodes -
  %
  % Syntax: [n_xyz, nodes] = extractNodes(filename)
  %
  % Inputs:
  %    - filename - relative or absolute path of the file that contains the Matrix
  %
  % Outputs:
  %    - n_xyz -
  %    - nodes - table containing the node numbers and corresponding dof of the interfaced DoFs
#+end_src

*** Optional Parameters
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
      filename
  end
#+end_src


*** Read the file
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  fid = fopen(filename,'rt');

  if fid == -1
      error('Error opening the file');
  end
#+end_src

*** Extract Nodes
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  n_xyz = []; % Contains nodes coordinates
  n_i = []; % Contains nodes indices

  while 1
      % Read a line
      nextline = fgetl(fid);

      % End of the file
      if ~isstr(nextline), break, end

      % Line just before the list of nodes coordinates
      if contains(nextline, 'NODE') && ...
              contains(nextline, 'X') && ...
              contains(nextline, 'Y') && ...
              contains(nextline, 'Z')

          while 1
              nextline = fgetl(fid);

              if nextline < 0, break, end

              c = sscanf(nextline, ' %f');

              if isempty(c), break, end

              n_xyz = [n_xyz; c(2:4)'];
              n_i = [n_i; c(1)];
          end
      end

      if nextline < 0, break, end

      % Line just before the list of node DOF
      if contains(nextline, 'NODE DOF')
          n_num = []; % Contains node numbers
          n_dof = {}; % Contains node directions

          while 1
              nextline = fgetl(fid);

              if nextline < 0, break, end

              c = sscanf(nextline, ' %d %s');

              if isempty(c), break, end

              n_num = [n_num; c(1)];

              n_dof{length(n_dof)+1} = char(c(2:end)');
          end

          nodes = table(n_num, string(n_dof'), 'VariableNames', {'node_i', 'node_dof'});
      end
   
      if nextline < 0, break, end
  end
#+end_src

*** Close the file
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  fclose(fid);
#+end_src

*** Get XYZ coordinates of the interface nodes
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  int_i = unique(nodes.('node_i')); % indices of interface nodes

  % Extract XYZ coordinates of only the interface nodes
  int_xyz = n_xyz(logical(sum(n_i.*ones(1, length(int_i)) == int_i', 2)), :);
#+end_src

** =extractEigs=: Extract Eigen Values and Eigen Vectors
:PROPERTIES:
:header-args:matlab+: :tangle src/extractEigs.m
:END:
<<sec:extractEigs>>

This Matlab function is accessible [[file:src/extractEigs.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  function [zm, w] = extractEigs(filename, args)
  % extractEigs -
  %
  % Syntax: [zm, w] = extractEigs(filename, args)
  %
  % Inputs:
  %    - filename - relative or absolute path of the file that contains the eigenvectors and eigenvalues
  %    - args - Optional parameters:
  %        - dirs - [6 x 1] - ones(6,1) (default)
  %                          - Vectors with 0 and 1 identifying directions to include in the modal matrix
  %                          - This corresponds to [Ux, Uy, Uz, Rx, Ry, Rz]
  %        - soft - 'ansys' (default) - Software used for the FEM
  %
  % Outputs:
  %    - zm - [(n x dofs) x m] - Modal Matrix containing the eigenvectors
  %                            - zm(1:n, i) corresponds to the eigenvector for mode i and for first dir considered
  %                            - zm((n-1)*j+1:n*j, i) corresponds to the eigenvector for i'th mode and for j'th dir considered
  %    - w  - [m x 1] - Eigenvalues [Hz]
#+end_src

*** Optional Parameters
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
      filename
      args.dirs (6,1) double {mustBeNumericOrLogical}            = ones(6,1)
      args.soft       char   {mustBeMember(args.soft,{'ansys'})} = 'ansys'
  end
#+end_src

*** Open the file
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  fid = fopen(filename,'rt');

  if fid == -1
      error('Error opening the file');
  end
#+end_src

*** Extract Eigenvalues - Ansys
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  if strcmp(args.soft, 'ansys')
      w = [];
      zm = [];

      while 1
          % Read a line
          nextline = fgetl(fid);

          % End of the file
          if ~isstr(nextline), break, end

          % Lines containing the mode numbers
          if contains(nextline, ' LOAD STEP=') && ...
                  contains(nextline, 'SUBSTEP=') && ...
                  ~contains(nextline, 'CUM')
              mode_num = sscanf(nextline, ' LOAD STEP= %*f  SUBSTEP= %f ');
          end

          % Lines containing the frequency of the modes
          if contains(nextline, 'FREQ=')
              w = [w, sscanf(nextline, ' FREQ= %f LOAD CASE= %*f')];
          end

          % Start of the eigenvectors
          if contains(nextline, 'ROTZ')
              zmi = [];

              % Read the eigenvectors for each of the nodes
              while 1
                  nextline = fgetl(fid);
                  c = sscanf(nextline, ' %f');
                  if isempty(c), break, end
                  zmi = [zmi; c(2:end)'];
              end

              zm (:, :, mode_num) = zmi;
          end
      end

      zm = reshape(zm(:, logical([0; args.dirs]), :), size(zm, 1)*sum(args.dirs), size(zm, 3));
  end
#+end_src

*** Close the file
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  fclose(fid);
#+end_src

** =normalizeEigs=: Normalize Eigen Vectors
:PROPERTIES:
:header-args:matlab+: :tangle src/normalizeEigs.m
:END:
<<sec:normalizeEigs>>

This Matlab function is accessible [[file:src/normalizeEigs.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  function [zn] = normalizeEigs(zm, args)
  % normalizeEigs - Normalize the eigenvectors
  %
  % Syntax: [zn] = normalizeEigs(zm, args)
  %
  % Inputs:
  %    - zm - Modal Matrix
  %    - args - Optional parameters:
  %        - method - 'mass' (default), 'unity' - Method used to normalize the eigenvectors
  %
  % Outputs:
  %    - zn - Normalized Modal Matrix
#+end_src

*** Optional Parameters
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
      zm
      args.m      double {mustBeNumeric} = 0
      args.method char   {mustBeMember(args.method,{'mass', 'unity'})} = 'mass'
  end
#+end_src

*** Normalize the Eigen Vectors - Mass Method
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_src matlab
  if strcmp(args.method, 'mass')
      if size(args.m) ~= [size(zm,1), size(zm,1)]
          error('The provided Mass matrix has not a compatible size with the Modal Matrix')
      end
   
      zn = zeros(size(zm));
      for i = 1:size(zm,2)
          zn(:,i) = zm(:,i)/sqrt(zm(:,i)'*args.m*zm(:,i));
      end
  end
#+end_src

*** Normalize the Eigen Vectors - Unity Method
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_src matlab
  if strcmp(args.method, 'unity')
    zn = zm./max(zm);
  end
#+end_src
** =reductionInOut=: Reduce the Modal matrix to some nodes
:PROPERTIES:
:header-args:matlab+: :tangle src/reductionInOut.m
:END:
<<sec:reductionInOut>>

This Matlab function is accessible [[file:src/reductionInOut.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
function [zr] = reductionInOut(zn, i_inputs, i_outputs)
% reductionInOut - Reduce the Modal Matrix to only specified nodes corresponding to Inputs and Ouputs
%
% Syntax: [zr] = reductionInOut(zn, i_inputs, i_outputs)
%
% Inputs:
%    - zn        - Normalized Modal Matrix
%    - i_inputs  - Node indices corresponding to inputs
%    - i_outputs - Node indices corresponding to inputs
%
% Outputs:
%    - zr - Reduced Normalized Modal Matrix
#+end_src

*** Arguments
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
      zn
      i_inputs  {mustBeInteger} = 0
      i_outputs {mustBeInteger} = 0
  end
#+end_src

*** Size Reduction
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  zr = zn([i_inputs, i_outputs], :);
#+end_src
** TODO =computeModalDamping= - Compute the Damping
:PROPERTIES:
:header-args:matlab+: :tangle src/computeModalDaping.m
:END:
<<sec:computeModalDaping>>

This Matlab function is accessible [[file:src/computeModalDaping.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  function [xi] = computeModalDaping(z, w, args)
  % computeModalDaping -
  %
  % Syntax: [xi] = computeModalDaping(z, w, args)
  %
  % Inputs:
  %    - z, w, args -
  %
  % Outputs:
  %    - xi -
#+end_src

*** Arguments
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
  end
#+end_src


** TODO =sortModes= - Sort Modes
:PROPERTIES:
:header-args:matlab+: :tangle src/sortModes.m
:END:
<<sec:sortModes>>

This Matlab function is accessible [[file:src/sortModes.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
function [modes_i] = sortModes(z, w, xi, args)
% sortModes -
%
% Syntax: [modes_i] = sortModes(z, w, xi, args)
%
% Inputs:
%    - z, w, xi, args -
%
% Outputs:
%    - modes_i -

end
#+end_src

*** Arguments
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
  end
#+end_src


** TODO =reduceModes= - Get Modes numbers for the reduced model
:PROPERTIES:
:header-args:matlab+: :tangle src/reduceModes.m
:header-args:matlab+: :comments none :mkdirp yes :eval no
:END:
<<sec:reduceModes>>

This Matlab function is accessible [[file:src/reduceModes.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
function [modes_i] = reduceModes(z, w, xi, args)
% reduceModes -
%
% Syntax: [modes_i] = reduceModes(z, w, xi, args)
%
% Inputs:
%    - z, w, xi, args -
%
% Outputs:
%    - modes_i -
#+end_src

*** Arguments
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
  end
#+end_src


** TODO =createStateSpaceModel= - Create the Reduced State Space Model
:PROPERTIES:
:header-args:matlab+: :tangle src/createStateSpaceModel.m
:header-args:matlab+: :comments none :mkdirp yes :eval no
:END:
<<sec:createStateSpaceModel>>

This Matlab function is accessible [[file:src/createStateSpaceModel.m][here]].

*** Function description
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
function [G] = createStateSpaceModel(z, w, xi, modes_i)
% createStateSpaceModel -
%
% Syntax: [G] = createStateSpaceModel(z, w, xi, modes_i)
%
% Inputs:
%    - z, w, xi, modes_i -
%
% Outputs:
%    - G -
#+end_src

*** Arguments
:PROPERTIES:
:UNNUMBERED: t
:END:
#+begin_src matlab
  arguments
  end
#+end_src

* Bibliography                                                        :ignore:
bibliographystyle:unsrt
bibliography:ref.bib
